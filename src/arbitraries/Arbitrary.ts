import {ArbitrarySize, FluentPick} from './types'
import {ChainedArbitrary, FilteredArbitrary, MappedArbitrary, NoArbitrary, UniqueArbitrary} from './internal'

export abstract class Arbitrary<A> {

  /**
   * The number of elements that can be generated by this `Arbitrary`.
   *
   * The returned size can be exact or an estimation.
   */
  abstract size(): ArbitrarySize

  /**
   * Generates a random element. This operation is stateless.
   */
  abstract pick(): FluentPick<A> | undefined

  /**
   * Returns `true` if this `Arbitrary` can generate a given element.
   *
   * In cases where the set of possible elements is unknown, this operation is expected to be optimistic - it should
   * return `false` only when a pick is guaranteed not to be generatable.
   *
   * TODO: should we include an "unknown" result?
   */
  abstract canGenerate<B extends A>(pick: FluentPick<B>): boolean

  /**
   * Returns a sample of picks of a given size.
   *
   * While this function doesn't pick corner cases, each pick is not necessarily independent from the others: different
   * arbitraries might choose to use smarter search strategies to maximize the probability of falsifying a property,
   * e.g. by including only unique elements.
   */
  sample(sampleSize = 10): FluentPick<A>[] {
    const result: FluentPick<A>[] = []
    for (let i = 0; i < sampleSize; i += 1) {
      const pick = this.pick()
      if (pick) result.push(pick)
      else break
    }

    return result
  }

  /**
   * The special cases for this arbitrary, which can be used during sampling to give higher weight to certain elements.
   */
  cornerCases(): FluentPick<A>[] { return [] }

  /**
   * Returns a sample of picks of a given size, possibly biased towards corner cases.
   */
  sampleWithBias(sampleSize = 10): FluentPick<A>[] {
    const cornerCases = this.cornerCases()

    if (sampleSize <= cornerCases.length)
      return this.sample(sampleSize)

    const sample = this.sample(sampleSize - cornerCases.length)
    sample.unshift(...cornerCases)

    return sample
  }

  /**
   * Given a pick known to falsify a property, returns a new arbitrary with simpler cases to be tested. This is part of
   * FluentCheck's behavior of searching for simpler counter-examples after one is found.
   */
  shrink<B extends A>(_initial: FluentPick<B>): Arbitrary<A> {
    return NoArbitrary
  }

  map<B>(f: (a: A) => B): Arbitrary<B> { return new MappedArbitrary(this, f) }
  filter(f: (a: A) => boolean): Arbitrary<A> { return new FilteredArbitrary(this, f) }
  chain<B>(f: (a: A) => Arbitrary<B>): Arbitrary<B> { return new ChainedArbitrary(this, f) }
  unique(): Arbitrary<A> { return new UniqueArbitrary(this) }

  toString(depth = 0): string { return ' '.repeat(depth * 2) + `Base Arbitrary: ${this.constructor.name}`  }
}
